<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="trainPage">
        <!-- <textarea id="result1" style="width: 100%; height: 100px;"></textarea> -->
        <!-- <textarea id="result2" style="width: 100%; height: 100px;"></textarea> -->
        <div class="trainTitle">
            <div class="backButton">
                <button class="button" id="train" onclick="window.location.href='./index.html'"><</button>
            </div>
            <h2 class="title">Entrainements</h2>
        </div>
        <div class="chartContent">
            <div id="chart"></div>
        </div>
        <div class="train"></div>
    </div>
    <script type="module">
        import { Controller } from './Controller/Controller.js';
        import { Canva } from './Model/Canva.js';
        import { topDoodle, finalValues, historyAverage, setTopDoodle, setFinalValues } from './Model/data.js';
        
        const results = [];
        const result1 = document.getElementById('result1');
        const result2 = document.getElementById('result2');

        async function initializeCanvases() {
            const promises = [];
            // const data = await loadData();

            const train = document.querySelector('.train')

            for (let i = 0; i < 90; i++) {
                const canvaContent = document.createElement('div')
                canvaContent.classList.add('canvaContent')
                const canvas = document.createElement('canvas');
                canvas.id = `my_canvas_${i}`;
                canvas.width = Canva.WIDTH;
                canvas.height = Canva.HEIGHT;
                canvas.style.margin = '10px';
                canvaContent.appendChild(canvas);
                train.appendChild(canvaContent)
                console.log(finalValues[i]);
                promises.push(initializeCanvas(canvas, finalValues[i]));
            }

            const results = await Promise.all(promises); // Exécuter toutes les instances en parallèle
            results.sort((a, b) => b.score - a.score);
            reproduction(results);
            // toJSon(finalValues);
            initializeCanvases();
            // toJSon(reproductions);
        }

        async function initializeCanvas(canvas, data = null) {
            const HEXTILES_IMAGE = new Image();
            HEXTILES_IMAGE.src = 'assets/game-tiles.png';

            await new Promise((resolve) => {
                HEXTILES_IMAGE.addEventListener('load', () => {
                resolve();
                });
            });

            const app = new Controller(HEXTILES_IMAGE, canvas.id, true, data);
            const result = await app.update(); // Attendre que le jeu se termine
            results.push(result);
            return result; // Retourner le résultat
        }

        async function loadData() {
            const response = await fetch("./data.json");
            return await response.json();
        }

        function toJSon(json) {
            const jsonResults = JSON.stringify(json, null, 2);
            const blob = new Blob([jsonResults], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'result.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function reproduction(results) {
            setTopDoodle(results.slice(0, 30));
            setFinalValues(topDoodle);
            historyAverage.push(topDoodle.reduce((acc, doodle) => acc + doodle.score, 0) / topDoodle.length);
            for (let i = 0; i < 60; i++) {
                const parent1 = topDoodle[Math.floor(Math.random() * topDoodle.length)];
                const parent2 = topDoodle[Math.floor(Math.random() * topDoodle.length)];
                const newMatrix = {
                    matrix1: averageMatrices(parent1.matrix1, parent2.matrix1),
                    matrix2: averageMatrices(parent1.matrix2, parent2.matrix2),
                    bais: parent1.bais,
                };
                finalValues.push(newMatrix);
            }

            function averageMatrices(matrix1, matrix2) {
                return matrix1.map((row, rowIndex) =>
                    row.map((value, colIndex) => (mutate(value + matrix2[rowIndex][colIndex]) / 2))
                );
            }

            function averageArray(array1, array2) {
                return array1.map((value, index) => (mutate(value + array2[index]) / 2));
            }
        }

        function mutate(value){
            return value + (Math.random() - 0.9);
        }

        initializeCanvases();
    </script>
    <script src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="module" src="chart.js" defer></script>
</body>
</html>